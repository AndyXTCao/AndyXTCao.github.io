---
layout:     post
title:      iOS实时性能检测
subtitle:   
date:       2019-09-07
author:     AndyCao
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - iOS
    - Objective-C
---

iOS实时性能检测一般有两种方案：
- FPS监测
- 主线程卡顿监测

### FPS检测
通常情况下，屏幕会保持60hz/s的刷新速度，每次刷新时会发出一个屏幕刷新信号，CADisplayLink允许我们注册一个与刷新信号同步的回调处理。可以通过屏幕刷新机制来展示fps值：
CADisplayLink在添加target的时候，会对target产生强引用。为了避免循环引用，先创建一个Proxy。

```swift
@interface WeakProxy : NSProxy
+ (instancetype)proxyWithTarget:(id)target;
@property (weak, nonatomic) id target;
@end

@implementation WeakProxy
+ (instancetype)proxyWithTarget:(id)target
{
    // NSProxy对象不需要调用init，因为它本来就没有init方法
    WeakProxy *proxy = [WeakProxy alloc];
    proxy.target = target;
    return proxy;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel
{
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation
{
    [invocation invokeWithTarget:self.target];
}

@end
```
下面是fps监测的核心代码
```swift
@interface FPSLabel : UILabel
- (void)startFpsMonitoring;
@end

@interface FPSLabel ()
{
    NSInteger _count;
    CFAbsoluteTime _lastUpadateTime;
}
@property (nonatomic, strong) CADisplayLink *link;
@end

@implementation FPSLabel

- (void)startFpsMonitoring {
    WeakProxy *proxy = [WeakProxy proxyWithTarget: self];
    self.link = [CADisplayLink displayLinkWithTarget:proxy selector: @selector(displayFps:)];
    [self.link addToRunLoop: [NSRunLoop mainRunLoop] forMode: NSRunLoopCommonModes];
}

- (void)displayFps: (CADisplayLink *)fpsDisplay {
    _count++;
    CFAbsoluteTime threshold = CFAbsoluteTimeGetCurrent() - _lastUpadateTime;
    if (threshold >= 1.0) {
        self.text = [NSString stringWithFormat:@"FPS:%.0f",_count / threshold];
        _lastUpadateTime = CFAbsoluteTimeGetCurrent();
    }
}

@end
```
经过测试，当fps保持在50以上时，列表的性能还是不错的。当出现卡顿的时候，fps会明显下滑。


### 主线程卡顿监控
通过子线程监测主线程的 runLoop，判断两个状态区域之间的耗时是否达到一定阈值。